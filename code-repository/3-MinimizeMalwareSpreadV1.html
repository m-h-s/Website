<!DOCTYPE html>
<html>

<head>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-47250740-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47250740-1');
</script>
 
 
<title> Minimize the Spread of Malware </title>

<link rel = "stylesheet"   href = "../css/repostyle.css" >

<meta name = "author" content = "Mahsa Sadi">

<meta name = "description" content = "code projects">

<meta name = "keywords" content = "Java, Code, Problem, Solution">

<meta name = "viewport" content = "width=device-width, initial-scale = 1.0">


<nav id= "navbar">
<a href = "../index.html">Home</a> &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Research and Publications.html">Research</a>   &nbsp &nbsp |  &nbsp &nbsp  
<a href = "../Honors and Awards.html">Honors and Awards</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href="../Code%20Repository.html">Code Repository</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Teaching Experience.html">Teaching</a> &nbsp &nbsp |  &nbsp &nbsp
<a href="">Interesting Research Projects</a>  
</nav>

</head>



<body>


<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<div id = "code-description">


<!-- Title -->

<p id= "heading"> Title: </p>

<p class = "strong" > Minimize the Spread of Malware - Version 1 </p> 

<!-- ///////  -->


<!-- Link to LeetCode -->

<p id= "heading">Link to LeetCode:</p>

<p> <a href = "https://leetcode.com/problems/minimize-malware-spread/"> https://leetcode.com/problems/minimize-malware-spread/ </a> </p>

<!-- ///////  -->


<!-- Problem -->

<p id = "heading"> Specification: </p>

<p> In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. <br>
	Some nodes <code> initial </code> are initially infected by malware.<br>
	Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.<br>
	This spread of malware will continue until no more nodes can be infected in this manner. <br><br>
	Suppose <code> M(initial) </code> is the final number of nodes infected with malware in the entire network, after the spread of malware stops. <br>
	We will remove one node from the <code> initial </code> list.  Return the node that if removed, would minimize <code> M(initial) </code>.  <br>
	If multiple nodes could be removed to minimize <code> M(initial)</code>, return such a node with the smallest index. <br>
	Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.<br> <br>
	
	Note: <br>
	 1 < graph.length = graph[0].length <= 300 <br>
	 0 <= graph[i][j] == graph[j][i] <= 1 <br>
	 graph[i][i] = 1 <br>
	 1 <= initial.length < graph.length <br>
	 0 <= initial[i] < graph.length <br>
</p>

<!-- ///////  -->

<!-- Examples -->

<p id = "heading"> Examples: </p>

<p class = "strong" > Example 1: </p>
<p> Input: graph = {{1,1,0},{1,1,0},{0,0,1}}, initial = {0,1} <br>
    Output: 0 <br>
</p>
<p class = "strong"> Example 2: </p>
<p>
Input: graph = {{1,0,0},{0,1,0},{0,0,1}}, initial = {0,2} <br>
Output: 0
</p>

<p class = "strong"> Example 3: </p>
<p>
Input: graph = {{1,1,1},{1,1,1},{1,1,1}}, initial = {1,2} <br>
Output: 1 <br>
</p>


<!-- ///////  -->


<!-- Signature -->

<p id = "heading"> Initial Code and Signature: </p>

<div id ="code-snippet2">
<code>
<pre class="prettyprint">
public interface MalwareSpreadMinimizer {

	
	public int minMalwareSpread(int[][] graph, int[] initial);
}
</pre>
</code>
</div>

<!-- ///////  -->


<!-- Solution  -->

<p id = "heading">  Algorithm: </p>


	 <ol>
	 
	 <li> For each given infected node in the given graph find the maximum neighborhood tree.</li>
	 <li> Return the node with the largest maximum tree and the smallest index. </li>
	 
	 </ol>
	 
	  Find the Maximum Neighborhood Tree for a Given Node in a Given Graph is equivalent to <br>
	     Breadth-First Traversal of the Graph Starting from the Given Node:
	 
	 <ol>
	 <li> Start from a given node. </li>
	 <li> Visit neighbors if not visited. </li>
	 <li> Repeat the visit for each neighbor. </li>
	 <li> Repeat until no new neighbors can be visited. </li>
	 <li> Record the count of visited nodes starting from the given node. </li>
	 </ol>

<!-- ///////  -->

<!-- RunTime Analysis  -->

<p id = "heading">  Run-Time Analysis: </p>
<p> </p>

<!-- ///////  -->



<!-- GitHub  -->

<p id ="heading"> GitHub Project: </p>

<p> <a href = "">  </a> </p>

<!-- ///////  -->

 
 <!-- Code  -->

<p id ="heading"> Code: </p>

<!-- ///////  -->
 
</div>

<div id = "code-snippet">

<code>
<pre class="prettyprint">
<!-- Code -->
import java.util.*;

/**
 * 
 * @author Mahsa Sadi 
 * @since 2020-02-20
 *
 */
public class MalwareSpreadMinimizerV2 implements MalwareSpreadMinimizer {

	/**
	 * Problem: Minimize the spread of malware
	 * 
	 * 
	 * 
	 * 
	 * Description:
	 * 
	 * In a network of nodes, each node i is directly connected to another node j if
	 * and only if graph[i][j] = 1. Some nodes initial are initially infected by
	 * malware. Whenever two nodes are directly connected and at least one of those
	 * two nodes is infected by malware, both nodes will be infected by malware.
	 * This spread of malware will continue until no more nodes can be infected in
	 * this manner. Suppose M(initial) is the final number of nodes infected with
	 * malware in the entire network, after the spread of malware stops. We will
	 * remove one node from the initial list. Return the node that if removed, would
	 * minimize M(initial). If multiple nodes could be removed to minimize
	 * M(initial), return such a node with the smallest index. Note that if a node
	 * was removed from the initial list of infected nodes, it may still be infected
	 * later as a result of the malware spread.
	 * 
	 * 
	 * Note: 1 < graph.length = graph[0].length <= 300 0 <= graph[i][j] ==
	 * graph[j][i] <= 1 graph[i][i] = 1 1 <= initial.length < graph.length 0 <=
	 * initial[i] < graph.length
	 * 
	 * 
	 * 
	 * 
	 * 
	 * Solution:
	 * 
	 * 1 - For each given infected node in the given graph find the maximum
	 * neighborhood tree.
	 * 
	 * 2- Return the node with the largest maximum tree and the smallest index
	 * 
	 * 
	 * 
	 * 
	 * Find the Maximum Neighborhood Tree for a Given Node in a Given Graph:
	 * 
	 * == Breadth-First Traversal of the Graph Starting from the Given Node:
	 * 
	 * 1- Start from a given node.
	 * 
	 * 2- Visit neighbors if not visited.
	 * 
	 * 3- Repeat the visit for each neighbor.
	 * 
	 * 4- Repeat until no new neighbors can be visited.
	 * 
	 * 5- Record the count of visited nodes starting from the given node
	 * 
	 * 
	 * 
	 * 
	 */

	int[] sizeOfMaxNeighborhoodTree;

	public int minMalwareSpread(int[][] graph, int[] initial) {

		int mostInfluentialNode = -1;
		int maxReachableNodes = -1;

		sizeOfMaxNeighborhoodTree = new int[graph[0].length];
		initializeArray(sizeOfMaxNeighborhoodTree, -1);

		for (Integer infectedNode : initial) {
			sizeOfMaxNeighborhoodTree[infectedNode] = findLengthOfMaxNeighborhoodTree(graph, infectedNode);

			if (maxReachableNodes <= sizeOfMaxNeighborhoodTree[infectedNode]
					&& (infectedNode < mostInfluentialNode || mostInfluentialNode == -1)) {
				maxReachableNodes = sizeOfMaxNeighborhoodTree[infectedNode];
				mostInfluentialNode = infectedNode;
			}
		}

		return mostInfluentialNode;
	}

	public void initializeArray(int[] array, int initialziationValue) {
		for (int i = 0; i < array.length; i++) {
			array[i] = initialziationValue;
		}
	}

	public int findLengthOfMaxNeighborhoodTree(int[][] graph, int infectedNode) {
		int numberOfNodes = graph[0].length;
		int[] visitedNodes = new int[numberOfNodes];

		List&lt;Integer&gt; nodesToBeVisited = new ArrayList&lt;Integer&gt;();

		int sizeOfMaxNeighborhoodTreeFromThisNode = 0;

		nodesToBeVisited.add(infectedNode);

		/**
		 * Breadth-First Traversal of Infected Node
		 */

		while (!nodesToBeVisited.isEmpty()) {

			int currentNode = nodesToBeVisited.remove(0);

			if (sizeOfMaxNeighborhoodTree[currentNode] == -1) {

				visitedNodes[currentNode] = 1;

				for (int i = 0; i < graph[currentNode].length; i++) {

					if (graph[currentNode][i] == 1 && visitedNodes[i] == 0) {
						visitedNodes[i] = 1;
						nodesToBeVisited.add(i);
						sizeOfMaxNeighborhoodTreeFromThisNode++;
					}

				}
			}

			else {
				sizeOfMaxNeighborhoodTreeFromThisNode += sizeOfMaxNeighborhoodTree[currentNode];
			}

		}

		return sizeOfMaxNeighborhoodTreeFromThisNode;

	}

}
<!-- ///////  -->
</pre>

</code>

</div>

<body>

</html>
