<!DOCTYPE html>
<html>

<head>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-47250740-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47250740-1');
</script>
 
 
<title> Minimize the Spread of Malware </title>

<link rel = "stylesheet"   href = "../css/repostyle.css" >

<meta name = "author" content = "Mahsa Sadi">

<meta name = "description" content = "code projects">

<meta name = "keywords" content = "Java, Code, Problem, Solution">

<meta name = "viewport" content = "width=device-width, initial-scale = 1.0">


<nav id= "navbar">
<a href = "../index.html">Home</a> &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Research and Publications.html">Research</a>   &nbsp &nbsp |  &nbsp &nbsp  
<a href = "../Honors and Awards.html">Honors and Awards</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href="../Code%20Repository.html">Code Repository</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Teaching Experience.html">Teaching</a> &nbsp &nbsp |  &nbsp &nbsp
<a href="">Interesting Research Projects</a>  
</nav>

</head>



<body>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<div id = "code-description">


<!-- Title -->

<p id= "heading"> Title: </p>

<p class = "strong" > Minimize the Spread of Malware - Version 2 </p> 

<!-- ///////  -->


<!-- Link to LeetCode -->

<p id= "heading">Link to LeetCode:</p>

<p> <a href = "https://leetcode.com/problems/minimize-malware-spread/"> https://leetcode.com/problems/minimize-malware-spread/ </a> </p>

<!-- ///////  -->


<!-- Problem -->

<p id = "heading"> Specification: </p>

<p> In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. <br>
	Some nodes <code> initial </code> are initially infected by malware.<br>
	Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.<br>
	This spread of malware will continue until no more nodes can be infected in this manner. <br><br>
	Suppose <code> M(initial) </code> is the final number of nodes infected with malware in the entire network, after the spread of malware stops. <br>
	We will remove one node from the <code> initial </code> list.  Return the node that if removed, would minimize <code> M(initial) </code>.  <br>
	If multiple nodes could be removed to minimize <code> M(initial)</code>, return such a node with the smallest index. <br>
	Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.<br> <br>
	
	Note: <br>
	 1 < graph.length = graph[0].length <= 300 <br>
	 0 <= graph[i][j] == graph[j][i] <= 1 <br>
	 graph[i][i] = 1 <br>
	 1 <= initial.length < graph.length <br>
	 0 <= initial[i] < graph.length <br>
</p>

<!-- ///////  -->

<!-- Examples -->

<p id = "heading"> Examples: </p>

<p class = "strong" > Example 1: </p>
<p> Input: graph = {{1,1,0},{1,1,0},{0,0,1}}, initial = {0,1} <br>
    Output: 0 <br>
</p>
<p class = "strong"> Example 2: </p>
<p>
Input: graph = {{1,0,0},{0,1,0},{0,0,1}}, initial = {0,2} <br>
Output: 0
</p>

<p class = "strong"> Example 3: </p>
<p>
Input: graph = {{1,1,1},{1,1,1},{1,1,1}}, initial = {1,2} <br>
Output: 1 <br>
</p>


<!-- ///////  -->


<!-- Signature -->

<p id = "heading"> Initial Code and Signature: </p>

<div id ="code-snippet2">
<code>
<pre class="prettyprint">
public interface MalwareSpreadMinimizer {

	
	public int minMalwareSpread(int[][] graph, int[] initial);
}
</pre>
</code>
</div>

<!-- ///////  -->


<!-- Solution  -->

<p id = "heading">  Algorithm: </p>

		<p>
		In an undirected graph, if two nodes (let's say A and B) are neighbors, <br>
		their reachability graphs are the same,<br>
		i.e.; whatever node is reachable from A is reachable from B, and vice versa,<br>
		i.e.; R (A) = R (B); R(A) and R (B) are initially equal to N (A) U N (B).<br>
		Therefore, neighbors can be unified and considered as one larger virtual node. <br><br>
		</p>


	 <ol>
	 
	 <li> Start from a given node n. </li>
	 <li> Enqueue neighbors of the given node (other than the node itself) [N(n)] if not visited.</li>
	 <li> Mark the neighbors as visited.</li>
	 <li> Neighbor i = Dequeue; </li>
	 <li> R (n) = N (n) U N (i). </li>
	 <li> R (i) = R (n). </li>
	 <li> Go to (2-) and repeat. </li>
	 <li> Repeat until the queue is empty. </li>
	 
	 </ol>
	 
	 

<!-- ///////  -->

<!-- RunTime Analysis  -->

<p id = "heading">  Run-Time Analysis: </p>
<p> </p>

<!-- ///////  -->

<!-- GitHub  -->

<p id ="heading"> GitHub Project: </p>

<p> <a href = "">  </a> </p>

<!-- ///////  -->
 
 <!-- Code  -->

<p id ="heading"> Code: </p>

<!-- ///////  -->
 
</div>

<div id = "code-snippet">

<code>
<pre class="prettyprint">
<!-- Code -->
import java.util.*;
/**
 * 
 * @author Mahsa Sadi
 * @since 2020-02-24
 *
 */

public class MalwareSpreadMinimizerV3 implements MalwareSpreadMinimizer {

	/**
	 * In an undirected graph, if two nodes (let's say A and B) are neighbors, their
	 * reachability graphs are the same, i.e.; whatever nodes is reachable from A is
	 * reachable from B, and vice versa, i.e.; * R (A) = R (B) = N (A) U N (B)
	 * Therefore, neighbor can be unified and considered as one larger virtual node.
	 * 
	 * 
	 * 
	 * 
	 * Solution:
	 * 
	 * 1- Start from a given node n. 
	 * 2- Enqueue neighbors of the given node (other than the node itself): (N(n)).
	 * 3- mark the neighbors as visited. 
	 * 4- neighbor i = Dequeue; 
	 * 5- R (n) = N (n) U N (i).
	 * 6- R (i) = R (n).
	 * 7- Go to (2-) and repeat.
	 * 8- Repeat until the queue is empty.
	 * 
	 */
	int mostInfluentialNode;
	int maxInfluence;
	int[][] reachabilityGraph;
	int numberOfNodes;
	int[] visited;

	int[] initialized;

	public int minMalwareSpread(int[][] graph, int[] initial) {

		numberOfNodes = graph.length;

		mostInfluentialNode = -1;
		maxInfluence = -1;

		reachabilityGraph = new int[numberOfNodes][numberOfNodes];
		

		visited = new int[numberOfNodes];
		initialized = new int[numberOfNodes];

		for (Integer infectedNode : initial) {
			findReachableNodesFor(graph, infectedNode);

			int sizeOfReachableNodes = 0;

			for (Integer i : reachabilityGraph[infectedNode])
				sizeOfReachableNodes += i;

			if ((sizeOfReachableNodes >= maxInfluence && infectedNode < mostInfluentialNode)
					|| mostInfluentialNode == -1) {
				mostInfluentialNode = infectedNode;
				maxInfluence = sizeOfReachableNodes;

			}

		}

		return mostInfluentialNode;

	}

	public void findReachableNodesFor(int[][] graph, int givenNode) {

		List&lt;Integer&gt; queue = new ArrayList&lt;Integer&gt;();

		if (visited[givenNode] != 1)

		{

			int currentNode = givenNode;
			visited[currentNode] = 1;

			boolean traverseFinished = false;

			while (!traverseFinished) {
				for (int j = 0; j < graph[currentNode].length; j++) {
					if (graph[currentNode][j] == 1 && visited[j] != 1 && j != currentNode) {
						queue.add(j);
						visited[j] = 1;
					}
				}

				if (!queue.isEmpty()) {
					currentNode = queue.remove(0);

					if (initialized[currentNode] != 1) {

						reachabilityGraph[currentNode] = graph[currentNode];
						initialized[currentNode] = 1;

					}

					if (initialized[givenNode] != 1) {

						reachabilityGraph[givenNode] = graph[givenNode];
						initialized[currentNode] = 1;

					}

					unify(givenNode, currentNode);
				}

				else
					traverseFinished = true;

			}

		}

	}

	public void unify(int givenNode, int currentNode) {

		for (int i = 0; i < numberOfNodes; i++) {
			if (reachabilityGraph[givenNode][i] + reachabilityGraph[currentNode][i] > 0)
				reachabilityGraph[givenNode][i] = 1;

			// The following else is unnecessary and can be removed.
			else
				reachabilityGraph[givenNode][i] = 0;
		}

		reachabilityGraph[currentNode] = reachabilityGraph[givenNode];

	}

}
<!-- ///////  -->
</pre>

</code>

</div>

<body>

</html>
