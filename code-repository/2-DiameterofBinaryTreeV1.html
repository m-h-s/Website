<!DOCTYPE html>
<html>

<head>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-47250740-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47250740-1');
</script>
 
 
<title> Diameter of Binary Tree </title>

<link rel = "stylesheet"   href = "../css/repostyle.css" >

<meta name = "author" content = "Mahsa Sadi">

<meta name = "description" content = "code projects">

<meta name = "keywords" content = "Java, Code, Problem, Solution">

<meta name = "viewport" content = "width=device-width, initial-scale = 1.0">


<nav id= "navbar">
<a href = "../index.html">Home</a> &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Research and Publications.html">Research</a>   &nbsp &nbsp |  &nbsp &nbsp  
<a href = "../Honors and Awards.html">Honors and Awards</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href="../Code%20Repository.html">Code Repository</a>  &nbsp &nbsp |  &nbsp &nbsp
<a href = "../Teaching Experience.html">Teaching</a> &nbsp &nbsp |  &nbsp &nbsp
<a href="">Interesting Research Projects</a>  
</nav>

</head>



<body>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<div id = "code-description">


<!-- Title -->

<p id= "heading"> Title: </p>

<p class = "strong" > Diameter of a Binary Tree - Version 1 </p> 

<!-- ///////  -->


<!-- Link to LeetCode -->

<p id= "heading">Link to LeetCode:</p>

<p> <a href = "https://leetcode.com/problems/diameter-of-binary-tree/"> https://leetcode.com/problems/diameter-of-binary-tree/ </a> </p>

<!-- ///////  -->


<!-- Problem -->

<p id = "heading"> Specification: </p>

<p> Given a binary tree, you need to compute the length of the diameter of the tree. <br>
The diameter of a binary tree is the length of the longest path between any two nodes in a tree.<br>
This path may or may not pass through the root. <br>
The length of path between two nodes is represented by the number of edges between them.
</p>

<!-- ///////  -->

<!-- Examples -->

<p id = "heading"> Examples: </p>

<p class = "strong" > Example 1: </p>
<p> Given the binary tree [1,2,3,4,5], <br>
    return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>
<p class = "strong"> Example 2: </p>

<p>  </p>

<!-- ///////  -->


<!-- Signature -->

<p id = "heading"> Initial Code and Signature: </p>

<div id ="code-snippet2">
<code>
<pre class="prettyprint">
public class DiameterOfBinaryTree {
	public int diameterOfBinaryTree (TreeNode root)
	{ }
	}
	
</pre>
</code>
</div>

<!-- ///////  -->


<!-- Solution  -->

<p id = "heading">  Algorithm: </p>

<p> Recursive Version: <br>
	 <ol>
	 
	 <li> Start from root </li>
	 <li> Calculate longest left and right paths from the current node </li>
	 <li> Update the "longest paths" if the sum of the longest paths from current node is greater than the sum of the "longest paths"</li>
	 <li> Go to the next node </li>
	 <li> Continue until all the nodes in the tree are visited </li>
	 <li> Return sum of the "longest paths" </li>
	 </ol>
    Calculate longest left and right paths from current node:
	 <ol>
	 <li> Is the node a leaf? </li>
	 <li> Yes: return [0,0] </li>
	 <li> No: return [max of (longest left and right paths from left child) + 1 , max of (longest left and right paths from right child ) + 1]</li>
	 </ol>
	 </p>

<!-- ///////  -->

<!-- RunTime Analysis  -->

<p id = "heading">  Run-Time Analysis: </p>
<p> </p>

<!-- ///////  -->



<!-- GitHub  -->

<p id ="heading"> GitHub Project: </p>

<p> <a href = "">  </a> </p>

<!-- ///////  -->

 
 <!-- Code  -->

<p id ="heading"> Code: </p>

<!-- ///////  -->
 
</div>

<div id = "code-snippet">

<code>
<pre class="prettyprint">
<!-- Code -->
/**
 * 
 * @author Mahsa Sadi
 * @since 2020-02-17 
 *
 */
public class DiameterOfBinaryTree {


	/**
	 * Problem: Diameter of a Binary Tree
	 * 
	 * 
	 * Description: Given a binary tree, you need to compute the length of the diameter of the tree. 
	 * The diameter of a binary tree is the length of the longest path between any two nodes in a tree. 
	 * This path may or may not pass through the root.
	 */

	/**
	 * Solution: 
	 * 1- Start from root
	 * 2- longest paths = [-1,-1]
	 * 3- Calculate farthest right and left paths from the current node
	 * 4- Update the longest paths if the sum of the farthest paths are longer than the sum of the longest paths 
	 * 5- Go to the next node
	 * 6- Continue until all the nodes are visited.
	 * 7- Return sum of the longest paths
	 * 
	 * 
	 * 
	 * Calculate farthest paths from current node:
	 * 1- Is the node a leaf?
	 * 	2-Yes: farthest path form node : [0,0]
	 *         3- Update longest path if this path is longer
	 * 2- No: 
	 *   2- Has left child?
	 *   	3- No: return [0, max of (farthest left and right paths from right child + 1)]
	 *     		 4- Update longest paths if this path is longer
	 *   2- Yes:
	 *   	3- Has right child?
	 *   		4- No: return [max of (farthest left and right paths from left child +1) , 0]
	 *          	5- Update longest paths if this path is longer
	 *      4- Yes: 
	 *      	5- return [max of (farthest path left and right from left child +1) , max of (farthest left and right path from right child + 1)]
	 *         	 	6- Update longest paths if this path is longer
	 * 

	 */


	private int longestPaths [] = {-1, -1};


	public int diameterOfBinaryTree (TreeNode root)
	{
		farthestPathFrom (root);
		return longestPaths [0] + longestPaths [1];
	}



	public int [] farthestPathFrom (TreeNode n)

	{   int farthestPaths [] = {-1, -1};


		if (n == null)
		{
			farthestPaths [0] = farthestPaths [1] = 0;
		}
	
	
		else if (isLeaf (n))
		{
			farthestPaths [0] = farthestPaths [1] = 0;
		}
	
		else 
		{
			int [] farthestPathsFromRight;
			int [] farthestPathsFromLeft;
	
			if (n.getLeftChild () == null )
			{
				farthestPaths [0] = 0;
				farthestPathsFromRight = farthestPathFrom (n.getRightChild ());
				farthestPaths [1] = Math.max (farthestPathsFromRight [0] + 1, farthestPathsFromRight [1] + 1);
				
			}
	
			else if (n.getRightChild () == null )
			{
				farthestPathsFromLeft = farthestPathFrom (n.getLeftChild ());
				farthestPaths [0] = Math.max (farthestPathsFromLeft [0] + 1 , farthestPathsFromLeft [1] + 1);
				farthestPaths [1] = 0;
			}
	
			else 
			{
				farthestPathsFromLeft = farthestPathFrom (n.getLeftChild ());
				farthestPathsFromRight = farthestPathFrom (n.getRightChild ());
	
				farthestPaths [0] = Math.max (farthestPathsFromLeft [0] + 1, farthestPathsFromLeft [1] + 1);
				farthestPaths [1] = Math.max (  farthestPathsFromRight [0] + 1, farthestPathsFromRight [1] + 1);
	
			}
	}


	
	if ( (farthestPaths [0] + farthestPaths [1]) > ( longestPaths [0] + longestPaths [1]))
		longestPaths = farthestPaths;

	return farthestPaths;
	}



	public boolean isLeaf (TreeNode n)
	{
		return n.getLeftChild() == null && n.getRightChild() == null;
	}


}
<!-- ///////  -->
</pre>

</code>

</div>

<body>

</html>
